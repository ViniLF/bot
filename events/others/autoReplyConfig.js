const { 
    EmbedBuilder, 
    ActionRowBuilder, 
    ButtonBuilder, 
    ModalBuilder, 
    TextInputBuilder,
    StringSelectMenuBuilder 
} = require("discord.js");
const { db, owner } = require("../../database/index");

module.exports = {
    name: "interactionCreate",
    run: async(interaction, client) => {
        const { customId, user, guild, member } = interaction;
        
        // Filtrar apenas intera√ß√µes de auto-reply
        if (!customId || !customId.startsWith("autoreply_")) return;

        // Verificar permiss√µes
        if (owner !== user.id) {
            if (!interaction.replied && !interaction.deferred) {
                return interaction.reply({
                    content: "‚ùå Voc√™ n√£o tem permiss√£o para usar esta funcionalidade.",
                    ephemeral: true
                });
            }
            return;
        }

        // Verificar se j√° foi respondido
        if (interaction.replied || interaction.deferred) {
            console.log(`‚ö†Ô∏è Intera√ß√£o auto-reply ${customId} j√° foi processada`);
            return;
        }

        try {
            console.log(`‚öôÔ∏è Auto-reply config: ${customId} | Usu√°rio: ${user.username}`);

            switch (customId) {
                case "autoreply_toggle_system":
                    await handleToggleSystem(interaction);
                    break;
                case "autoreply_manage_words":
                    await handleManageWords(interaction);
                    break;
                case "autoreply_settings":
                    await handleSettings(interaction);
                    break;
                case "autoreply_test":
                    await handleTest(interaction);
                    break;
                case "autoreply_stats":
                    await handleStats(interaction);
                    break;
                case "autoreply_reset":
                    await handleReset(interaction);
                    break;
                case "autoreply_add_word":
                    await handleAddWord(interaction);
                    break;
                case "autoreply_add_word_modal":
                    await handleAddWordModal(interaction);
                    break;
                case "autoreply_edit_word":
                    await handleEditWord(interaction);
                    break;
                case "autoreply_delete_word":
                    await handleDeleteWord(interaction);
                    break;
                case "autoreply_back_main":
                    await handleBackToMain(interaction);
                    break;
                default:
                    if (customId.startsWith("autoreply_edit_")) {
                        await handleEditSpecificWord(interaction, customId);
                    } else if (customId.startsWith("autoreply_delete_")) {
                        await handleDeleteSpecificWord(interaction, customId);
                    } else if (customId.startsWith("autoreply_toggle_")) {
                        await handleToggleSpecificWord(interaction, customId);
                    } else {
                        console.log(`‚ùì CustomId auto-reply n√£o reconhecido: ${customId}`);
                    }
            }

        } catch (error) {
            console.error(`üö´ Erro no autoReplyConfig (${customId}):`, error);
            
            if (!interaction.replied && !interaction.deferred) {
                try {
                    await interaction.reply({
                        content: "‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.",
                        ephemeral: true
                    });
                } catch (replyError) {
                    console.error("Erro ao responder com erro:", replyError.message);
                }
            }
        }
    }
};

async function handleToggleSystem(interaction) {
    await interaction.deferUpdate();
    
    const config = await db.get("autoReply") || {};
    config.enabled = !config.enabled;
    await db.set("autoReply", config);
    
    await reloadMainPanel(interaction);
}

async function handleManageWords(interaction) {
    const config = await db.get("autoReply") || { triggers: {} };
    const words = Object.keys(config.triggers);

    const embed = new EmbedBuilder()
        .setTitle("üìù Gerenciar Palavras-Chave")
        .setDescription("Adicione, edite ou remova palavras que ativam respostas autom√°ticas.")
        .setColor("#00FFFF");

    let components = [
        new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId("autoreply_add_word")
                    .setLabel("Adicionar Palavra")
                    .setStyle(3)
                    .setEmoji("‚ûï"),
                new ButtonBuilder()
                    .setCustomId("autoreply_back_main")
                    .setLabel("Voltar")
                    .setStyle(2)
                    .setEmoji("‚¨ÖÔ∏è")
            )
    ];

    if (words.length > 0) {
        let wordsText = "";
        words.forEach((word, index) => {
            const wordConfig = config.triggers[word];
            const status = wordConfig.enabled ? "üü¢" : "üî¥";
            const type = wordConfig.wholeWordOnly ? "üìù Palavra exata" : "üî§ Cont√©m texto";
            const case_ = wordConfig.caseSensitive ? "Aa" : "aa";
            
            wordsText += `**${index + 1}.** ${status} \`${word}\` (${type}, ${case_})\n`;
            wordsText += `   ‚îî "${wordConfig.embed.title}"\n\n`;
        });

        embed.addFields({
            name: `üìã Palavras Configuradas (${words.length})`,
            value: wordsText.trim()
        });

        // Adicionar select menu para editar/deletar
        const selectOptions = words.map((word, index) => ({
            label: word,
            description: config.triggers[word].embed.title.substring(0, 50),
            value: word,
            emoji: config.triggers[word].enabled ? "üü¢" : "üî¥"
        }));

        if (selectOptions.length > 0) {
            components.unshift(
                new ActionRowBuilder()
                    .addComponents(
                        new StringSelectMenuBuilder()
                            .setCustomId("autoreply_word_selected")
                            .setPlaceholder("Selecione uma palavra para editar...")
                            .addOptions(selectOptions.slice(0, 25)) // M√°ximo 25 op√ß√µes
                    )
            );
        }
    } else {
        embed.addFields({
            name: "üìã Palavras Configuradas",
            value: "Nenhuma palavra configurada ainda.\nClique em **Adicionar Palavra** para come√ßar."
        });
    }

    await interaction.update({
        embeds: [embed],
        components: components
    });
}

async function handleAddWord(interaction) {
    const modal = new ModalBuilder()
        .setCustomId("autoreply_add_word_modal")
        .setTitle("Adicionar Nova Palavra-Chave");

    const wordInput = new TextInputBuilder()
        .setCustomId("word")
        .setLabel("Palavra-chave")
        .setStyle(1)
        .setMaxLength(50)
        .setPlaceholder("Ex: ip, discord, ajuda")
        .setRequired(true);

    const titleInput = new TextInputBuilder()
        .setCustomId("title")
        .setLabel("T√≠tulo da resposta")
        .setStyle(1)
        .setMaxLength(256)
        .setPlaceholder("Ex: üåê IP do Servidor")
        .setRequired(true);

    const descriptionInput = new TextInputBuilder()
        .setCustomId("description")
        .setLabel("Descri√ß√£o da resposta")
        .setStyle(2)
        .setMaxLength(4000)
        .setPlaceholder("Ex: Nosso IP √©: play.exemplo.com")
        .setRequired(true);

    const colorInput = new TextInputBuilder()
        .setCustomId("color")
        .setLabel("Cor da embed (opcional)")
        .setStyle(1)
        .setMaxLength(7)
        .setPlaceholder("#00FFFF")
        .setRequired(false);

    const footerInput = new TextInputBuilder()
        .setCustomId("footer")
        .setLabel("Rodap√© (opcional)")
        .setStyle(1)
        .setMaxLength(2048)
        .setPlaceholder("Ex: Conecte-se e divirta-se!")
        .setRequired(false);

    modal.addComponents(
        new ActionRowBuilder().addComponents(wordInput),
        new ActionRowBuilder().addComponents(titleInput),
        new ActionRowBuilder().addComponents(descriptionInput),
        new ActionRowBuilder().addComponents(colorInput),
        new ActionRowBuilder().addComponents(footerInput)
    );

    await interaction.showModal(modal);
}

async function handleAddWordModal(interaction) {
    await interaction.deferUpdate();

    const word = interaction.fields.getTextInputValue("word").toLowerCase().trim();
    const title = interaction.fields.getTextInputValue("title");
    const description = interaction.fields.getTextInputValue("description");
    const color = interaction.fields.getTextInputValue("color") || "#00FFFF";
    const footer = interaction.fields.getTextInputValue("footer") || null;

    // Validar palavra
    if (!word || word.length === 0) {
        return await interaction.followUp({
            content: "‚ùå A palavra-chave n√£o pode estar vazia.",
            ephemeral: true
        });
    }

    const config = await db.get("autoReply") || { triggers: {} };

    if (config.triggers[word]) {
        return await interaction.followUp({
            content: `‚ùå A palavra "${word}" j√° est√° configurada.`,
            ephemeral: true
        });
    }

    // Adicionar nova palavra
    config.triggers[word] = {
        enabled: true,
        embed: {
            title,
            description,
            color,
            footer,
            banner: null
        },
        caseSensitive: false,
        wholeWordOnly: true
    };

    await db.set("autoReply", config);

    await interaction.followUp({
        content: `‚úÖ Palavra "${word}" adicionada com sucesso!`,
        ephemeral: true
    });

    // Voltar para o gerenciamento
    setTimeout(async () => {
        await handleManageWords(interaction);
    }, 1500);
}

async function handleSettings(interaction) {
    const config = await db.get("autoReply") || { settings: {} };
    const settings = config.settings || {};

    const embed = new EmbedBuilder()
        .setTitle("‚öôÔ∏è Configura√ß√µes do Auto-Reply")
        .setDescription("Configure o comportamento do sistema de resposta autom√°tica.")
        .setColor("#00FFFF")
        .addFields(
            {
                name: "‚è±Ô∏è Cooldown",
                value: `\`${settings.cooldownSeconds || 5} segundos\``,
                inline: true
            },
            {
                name: "üóëÔ∏è Deletar Original",
                value: settings.deleteOriginal ? "`üü¢ Sim`" : "`üî¥ N√£o`",
                inline: true
            },
            {
                name: "üìä Max. por Usu√°rio",
                value: `\`${settings.maxTriggersPerUser || 3}\``,
                inline: true
            }
        );

    const components = [
        new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId("autoreply_toggle_delete")
                    .setLabel(settings.deleteOriginal ? "N√£o Deletar Original" : "Deletar Original")
                    .setStyle(settings.deleteOriginal ? 4 : 3)
                    .setEmoji("üóëÔ∏è"),
                new ButtonBuilder()
                    .setCustomId("autoreply_set_cooldown")
                    .setLabel("Alterar Cooldown")
                    .setStyle(2)
                    .setEmoji("‚è±Ô∏è")
            ),
        new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId("autoreply_back_main")
                    .setLabel("Voltar")
                    .setStyle(2)
                    .setEmoji("‚¨ÖÔ∏è")
            )
    ];

    await interaction.update({
        embeds: [embed],
        components: components
    });
}

async function handleStats(interaction) {
    const stats = await db.get("autoReplyStats") || {};
    const config = await db.get("autoReply") || { triggers: {} };

    const embed = new EmbedBuilder()
        .setTitle("üìä Estat√≠sticas do Auto-Reply")
        .setDescription("Veja como as palavras est√£o sendo utilizadas.")
        .setColor("#00FFFF");

    if (Object.keys(stats).length === 0) {
        embed.addFields({
            name: "üìà Estat√≠sticas",
            value: "Nenhuma estat√≠stica dispon√≠vel ainda."
        });
    } else {
        let statsText = "";
        let totalUses = 0;

        // Ordenar por mais utilizadas
        const sortedStats = Object.entries(stats).sort((a, b) => b[1].count - a[1].count);

        for (const [word, data] of sortedStats) {
            totalUses += data.count;
            const lastUsed = data.lastUsed ? new Date(data.lastUsed).toLocaleDateString('pt-BR') : "Nunca";
            statsText += `üéØ **${word}**: ${data.count} uso(s) | √öltimo: ${lastUsed}\n`;
        }

        embed.addFields(
            {
                name: "üìà Total de Usos",
                value: `\`${totalUses}\``,
                inline: true
            },
            {
                name: "üìù Palavras Ativas",
                value: `\`${Object.keys(config.triggers).length}\``,
                inline: true
            },
            {
                name: "üèÜ Mais Usadas",
                value: statsText || "Nenhum dado dispon√≠vel"
            }
        );
    }

    const components = [
        new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId("autoreply_clear_stats")
                    .setLabel("Limpar Estat√≠sticas")
                    .setStyle(4)
                    .setEmoji("üóëÔ∏è"),
                new ButtonBuilder()
                    .setCustomId("autoreply_back_main")
                    .setLabel("Voltar")
                    .setStyle(2)
                    .setEmoji("‚¨ÖÔ∏è")
            )
    ];

    await interaction.update({
        embeds: [embed],
        components: components
    });
}

async function handleTest(interaction) {
    await interaction.deferUpdate();

    const config = await db.get("autoReply");
    if (!config || !config.enabled) {
        return await interaction.followUp({
            content: "‚ùå Sistema auto-reply est√° desativado.",
            ephemeral: true
        });
    }

    const words = Object.keys(config.triggers);
    if (words.length === 0) {
        return await interaction.followUp({
            content: "‚ùå Nenhuma palavra configurada para testar.",
            ephemeral: true
        });
    }

    const randomWord = words[Math.floor(Math.random() * words.length)];
    const wordConfig = config.triggers[randomWord];

    const embed = new EmbedBuilder()
        .setTitle("üß™ Teste do Sistema Auto-Reply")
        .setDescription(`Simulando resposta para a palavra: **${randomWord}**`)
        .setColor("#FFA500")
        .addFields({
            name: "üìã Pr√©via da Resposta",
            value: `**T√≠tulo:** ${wordConfig.embed.title}\n**Descri√ß√£o:** ${wordConfig.embed.description}\n**Cor:** ${wordConfig.embed.color}`
        });

    await interaction.followUp({
        embeds: [embed],
        ephemeral: true
    });
}

async function handleReset(interaction) {
    const modal = new ModalBuilder()
        .setCustomId("autoreply_reset_modal")
        .setTitle("Resetar Sistema Auto-Reply");

    const confirmInput = new TextInputBuilder()
        .setCustomId("confirm")
        .setLabel("Digite 'CONFIRMAR' para resetar")
        .setStyle(1)
        .setMaxLength(9)
        .setMinLength(9)
        .setPlaceholder("CONFIRMAR")
        .setRequired(true);

    modal.addComponents(new ActionRowBuilder().addComponents(confirmInput));
    await interaction.showModal(modal);
}

async function handleBackToMain(interaction) {
    // Verificar timeout antes de deferir
    const now = Date.now();
    const interactionTime = interaction.createdTimestamp;
    const timeElapsed = now - interactionTime;
    
    if (timeElapsed > 2500) {
        console.log(`‚è∞ Intera√ß√£o auto-reply expirou (${timeElapsed}ms) - ignorando`);
        return;
    }

    // Verifica√ß√£o dupla de seguran√ßa
    if (interaction.replied || interaction.deferred) {
        console.log('‚ö†Ô∏è Intera√ß√£o auto-reply j√° foi processada');
        return;
    }

    try {
        await interaction.deferUpdate();
        await reloadMainPanel(interaction);
    } catch (error) {
        console.error('Erro ao voltar ao painel principal:', error);
    }
}

async function reloadMainPanel(interaction) {
    // Implementar a recarga do painel principal aqui
    // (c√≥digo similar ao comando auto-reply principal)
    const autoReplyConfig = await db.get("autoReply") || {
        enabled: false,
        triggers: {},
        settings: { cooldownSeconds: 5, deleteOriginal: false, maxTriggersPerUser: 3 }
    };

    // Garantir que settings existe
    if (!autoReplyConfig.settings) {
        autoReplyConfig.settings = {
            cooldownSeconds: 5,
            deleteOriginal: false,
            maxTriggersPerUser: 3
        };
        await db.set("autoReply", autoReplyConfig);
    }

    const embed = new EmbedBuilder()
        .setTitle("‚öôÔ∏è Painel Auto-Reply - Resposta Autom√°tica")
        .setDescription("Configure respostas autom√°ticas para palavras espec√≠ficas.")
        .setColor("#00FFFF")
        .addFields(
            {
                name: "üìä Status do Sistema",
                value: autoReplyConfig.enabled ? "`üü¢ Ativado`" : "`üî¥ Desativado`",
                inline: true
            },
            {
                name: "üéØ Palavras Configuradas",
                value: Object.keys(autoReplyConfig.triggers).length > 0 
                    ? Object.keys(autoReplyConfig.triggers).map(trigger => `\`${trigger}\``).join(", ")
                    : "`Nenhuma palavra configurada`",
                inline: true
            },
            {
                name: "‚è±Ô∏è Cooldown",
                value: `\`${autoReplyConfig.settings.cooldownSeconds || 5}s\``,
                inline: true
            }
        )
        .setFooter({ text: "Configure palavras-chave e suas respostas autom√°ticas" })
        .setTimestamp();

    // Verificar se h√° palavras configuradas
    const hasWords = Object.keys(autoReplyConfig.triggers).length > 0;
    
    // Criar bot√µes de a√ß√£o
    const components = [
        new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId("autoreply_toggle_system")
                    .setLabel(autoReplyConfig.enabled ? "Desativar Sistema" : "Ativar Sistema")
                    .setStyle(autoReplyConfig.enabled ? 4 : 3)
                    .setEmoji(autoReplyConfig.enabled ? "üî¥" : "üü¢"),
                new ButtonBuilder()
                    .setCustomId("autoreply_manage_words")
                    .setLabel("Gerenciar Palavras")
                    .setStyle(1)
                    .setEmoji("üìù"),
                new ButtonBuilder()
                    .setCustomId("autoreply_settings")
                    .setLabel("Configura√ß√µes")
                    .setStyle(2)
                    .setEmoji("‚öôÔ∏è")
            ),
        new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId("autoreply_test")
                    .setLabel("Testar Sistema")
                    .setStyle(2)
                    .setEmoji("üß™")
                    .setDisabled(!autoReplyConfig.enabled || !hasWords),
                new ButtonBuilder()
                    .setCustomId("autoreply_stats")
                    .setLabel("Estat√≠sticas")
                    .setStyle(2)
                    .setEmoji("üìä"),
                new ButtonBuilder()
                    .setCustomId("autoreply_reset")
                    .setLabel("Resetar Tudo")
                    .setStyle(4)
                    .setEmoji("üóëÔ∏è")
            )
    ];

    // Adicionar informa√ß√µes detalhadas se houver palavras configuradas
    if (hasWords) {
        let wordsInfo = "";
        for (const [word, config] of Object.entries(autoReplyConfig.triggers)) {
            const status = config.enabled ? "üü¢" : "üî¥";
            const caseSensitive = config.caseSensitive ? "Aa" : "aa";
            const wholeWord = config.wholeWordOnly ? "üìù" : "üî§";
            wordsInfo += `${status} **${word}** (${caseSensitive} ${wholeWord})\n`;
            wordsInfo += `   ‚îî "${config.embed.title}"\n\n`;
        }

        embed.addFields({
            name: "üìã Palavras Configuradas",
            value: wordsInfo.trim(),
            inline: false
        });
    }

    await interaction.editReply({
        embeds: [embed],
        components: components
    });
}